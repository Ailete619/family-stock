# 詳細設計書

## 1. データモデル詳細

### 1.1 StockItem
| 属性 | 型 | 説明 |
| --- | --- | --- |
| `id` | `String` (`@Attribute(.unique)`) | lowercased UUID。Supabase 側と形式統一。 |
| `userId` | `String` | Supabase `auth.uid` に紐づくユーザー識別子。 |
| `name` | `String` | 物品名。 |
| `category` | `String?` | 任意カテゴリ。 |
| `updatedAt` | `Date` | 最終更新日時。同期の衝突解決にも使用。 |
| `isArchived` | `Bool` | アーカイブ済みフラグ。ソフト削除用。 |
| `quantityInStock` | `Double` | 現在庫量。 |
| `quantityFullStock` | `Double` | 補充時の目標量。 |

### 1.2 ShoppingListEntry
| 属性 | 型 | 説明 |
| --- | --- | --- |
| `id` | `String` | lowercased UUID。 |
| `userId` | `String` | 所有ユーザー。 |
| `itemId` | `String` | `StockItem.id` への FK。 |
| `desiredQuantity` | `Double` | 欲しい数量。 |
| `unit` | `String` | 単位（pcs, g など）。 |
| `note` | `String?` | メモ。 |
| `updatedAt` | `Date` | 同期衝突用。 |
| `isDeleted` | `Bool` | レシート化後の削除管理。 |
| `isCompleted` | `Bool` | チェックボックス状態。 |

### 1.3 Receipt / ReceiptItem
- `Receipt`: `id`, `userId`, `shopName`, `timestamp`, `amount?`, `@Relationship var items: [ReceiptItem]`
- `ReceiptItem`: `id`, `itemName`, `quantity`, `receipt: Receipt?`

### 1.4 PendingSync
| 属性 | 説明 |
| --- | --- |
| `entityType` | `"StockItem"`, `"ShoppingListEntry"`, `"Receipt"` など。 |
| `entityId` | 対象エンティティの ID。 |
| `operation` | `"create"`, `"update"`, `"delete"`, `"upsert"` など。 |
| `retryCount` | 最大 5 回。 |
| `lastAttempt` | 最終送信日時。 |
| `errorMessage` | 直近の失敗理由。 |

## 2. サービス詳細

### 2.1 SyncService
- `pullAll()`：`pullItems`, `pullShopping`, `pullReceipts` を直列実行。各メソッドで Supabase から `updated_at` フィルタ付き GET。
- `pushItem(_:)`：`StockItem.toDTO()` → `itemRepo.upsert`。失敗時は OfflineQueue へ。
- `deleteItem(_:)` など delete 系は Supabase DELETE API 実行。
- `processPendingSyncs()`：`offlineQueue?.processPendingSyncs()` を委譲。
- `getPendingSyncCount()`：OfflineQueue 経由でカウントを返す。

### 2.2 OfflineQueueService
1. `queueSync(entityType:entityId:operation:)`  
   - `PendingSync` を生成し `ModelContext` へ insert。  
   - 成功後、`processPendingSyncs()` を非同期起動。
2. `processPendingSyncs()`  
   - `FetchDescriptor` で `PendingSync` を createdAt 昇順に取得。  
   - `isProcessing` フラグで多重起動を抑止。  
   - 各エントリに対し `processSingleSync(_:)`。
3. `processSingleSync(_:)`  
   - `retryCount >= 5` なら削除（ドロップ）して return。  
   - `retryCount++` → `syncService` に対応メソッドを呼ぶ。  
   - 例: (`"StockItem"`, `"delete"`) → `await syncService.deleteItem`.  
   - 成功時は `context.delete(pending)`、失敗時は `errorMessage` を保持。

### 2.3 Repository 実装
- `ItemRepository` / `ShoppingListEntryRepository` / `ReceiptRepository` が `HTTPClient` を通じて Supabase REST を叩く。  
- `fetchUpdatedSince` は `updated_at` クエリパラメータを使用。  
- `upsert` は既存レコード確認 → コンフリクトなら `ConflictResolver`。  
- `delete` は ID 条件で DELETE。

## 3. UI 詳細

### 3.1 RootView
- `TabView` で 4 画面を切替。`ScenePhase` 変化で `syncService?.processPendingSyncs()`。
- 認証状態を `SupabaseClient.shared` で監視。

### 3.2 StockListView / StockListRow
- `@Query(sort: \StockItem.name)` でアクティブ在庫を取得 → `isArchived == false` のみ表示。
- `StockListRow` ボタン:
  - `EditButton_<id>`: `StockItemSheet` (edit) を開く。
  - `DecreaseButton_<id>`: 数量減少 → `updateQuantity`.
  - `AddToShoppingButton_<id>`: `addToShoppingList`.
  - `DeleteButton_<id>`: アラート経由でアーカイブ。
- `updateQuantity(_:)` → `context.save()` 後、`Task` で `syncService.pushItem`.
- `addToShoppingList(_:)` → SwiftData で `ShoppingListEntry` を作成/更新 → 同期。

### 3.3 StockItemSheet
- `Mode.create/edit` を保持。`Form` で Name/Category/Quantity/FullStock 入力。
- `save()` にてバリデーション → `StockItem` 生成/更新 → `context.save()`。
- `quantityInStock == 0` なら `addToShoppingList`.

### 3.4 ShoppingListView / ShoppingListRow
- `@Query` で `isDeleted == false` のエントリを取得。
- `ShoppingListRow` では数量テキストフィールド、完了トグル、アクセシビリティ ID (`ShoppingItem_<sanitizedName>`) を付与。
- 完了したアイテムが存在する場合のみ「Save Receipt」ボタンを表示。

### 3.5 ReceiptListView / ReceiptDetailView
- 完了済みレシートの一覧、タップで詳細へ遷移。`Receipt` の `items` を表示。

### 3.6 SettingsView（概要）
- 同期状況表示、手動 `processPendingSyncs`、ログアウトなど（コード参照）。

## 4. ビジネスルール / フロー
1. **在庫 → 買い物自動追加**  
   - `StockListRow` もしくは `StockItemSheet` が数量 0 を検知 → `ShoppingListEntry` 追加 or 更新。  
   - `desiredQuantity` には `quantityFullStock` を使用（未設定の場合 1）。
2. **買い物完了 → レシート生成**  
   - 完了済みエントリを `ShoppingListView` で選択 → `Receipt` 作成フォームへ送る。  
   - 保存時: レシート作成 / レシートアイテム作成 / 在庫再補充 / エントリ削除フラグ。
3. **同期コンフリクト**  
   - Repositories に `ConflictResolver` を実装済み（last-write-wins）。
4. **オフラインリトライ**  
   - 失敗時 `retryCount++`。5 回超でキューから削除（ログに warning）。

## 5. テスト設計詳細
- **StockItemTests**: コンストラクタ / SwiftData CRUD / ID 一意性 / 量の境界値。
- **StockItemMappingTests**: `upsert` の ID 正規化、DTO Round Trip。
- **OfflineQueueServiceTests**:  
  - 正常同期（`queueSync` → `processPendingSyncs`）  
  - 対象不在時のリトライと `errorMessage` 記録  
  - `retryCount >= 5` の削除。
- **StockListViewSyncTests**: 現状は ModelContext 直接操作で挙動を模擬（将来的にリファクタ予定）。
- **FamilyStockUITests**: タブ遷移、在庫追加、ショッピング追加、完了チェック、レシート保存など。アクセシビリティ ID を利用。

## 6. 例外・ログ
- 保存失敗: `assertionFailure("Failed to ...")` + エラーメッセージ。
- 同期失敗: `print("❌ Push ...")` 形式でログ。`OfflineQueueService` は進捗を絵文字で表示。

## 7. 将来拡張に向けた考慮
- モデルに `userId` を保持しているため、世帯シェア機能やマルチユーザー対応が容易。
- `SyncServiceProtocol` で抽象化しており、ユニットテストやモックへの差し替えが可能。
- `PendingSync` は `entityType` + `operation` 汎用構造のため、新規エンティティ追加も容易。
- アクセシビリティ ID を体系化し、UI テストの安定運用を図る。
